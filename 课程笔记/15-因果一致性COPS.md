# 因果一致性COPS

## 1. 最终一致性

最终一致性属于弱一致性，它意味着所有的写操作消息最终都到达了⽬标位置并被处理后，所有副本上的数据都将一致。

在有多个事务同时进行的情况下，事务执行的顺序对最终结果是有影响的，因此保证所有副本服务器执行相同的事务顺序非常重要。保证事务执行顺序一致性一般有两种方案：

- 每个事务产生时加时间戳，每个副本服务器都要按照时间戳来执行这些事务，同时所有服务器还要同步时钟（Lamport Clocks）；

- 新加入一个sync指令，每次发生写操作时，往sync操作符中传⼊写入的key以及⼀个版本号，sync会一直等待直到所有副本的这个key的版本号都大于等于sync中记录的版本号。

## 2. COPS设计

### 2.1 Logging服务器

为了写操作能够获取本地的写入速度而不用等待其它数据中心同步，同时能够实现数据中心的写入操作同步，COPS采用了以下方案：

- 每个数据中心有一台专门存储日志的服务器，每当该数据中心发生写入操作时，本地数据中心都会将写入操作的日志存入日志服务器中；

- 存入日志后，本地数据中心返回消息给客户端，客户端这边可以结束操作；

- 接下来，日志服务器再将日志同步到其它数据中心的日志服务器上，其它数据中心会从自己的日志服务器读取最新日志并执行。

**该方案既可以大大提高写入操作的速度，又可以保证所有数据中心的操作顺序一致。** 系统结构如下图所示：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-27-19-51-25-20230127194843.png" alt="" width="432" data-align="center">

这个方案的问题是，每个数据中心太过于依赖单个日志服务器来实现同步。

### 2.2 client context

当COPS client在本地执⾏读和写操作的时候，它们会将它们所做事情的顺序信息累积起来，这种⽅案的粒度要⽐logging⽅案更加细。当client执⾏put操作的时候，这些信息会被发送到远程数据中⼼，这些信息就是client context。

举例说，client执行了如下操作：

```
get(x, v2)
get(y, v4)
put(z, 5, v3)
```

那么，put这个操作是要同步到其它数据中心的，在同步的过程中，它会将它前面的两个get操作作为context一并发送给其它数据中心：

```
put(z, 5, v3, (x:v2, y:v4))
```

(x:v2, y:v4)被称为dependency信息。该操作意味着，其它服务器要写入z，必须当它的x版本为v2，y版本为v4时才能写入。

接下来如果还有put操作，则它不需要再把x和y的信息作为context，而是将z的信息作为context：

```
put(a, 6, v2, (z:v3))
```

这个方案避免了logging服务器方案过于依赖单个日志服务器的问题，但是它会出现依赖链条导致同步写入陷入长期等待的问题，也就是put(z)操作依赖的x和y数据，它们也会依赖其它数据，只要链条中一个数据拖延，同步时间就会比较长。

这种COPS实现⽅案通常叫做因果⼀致性（causal consistency），如下图所示：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-27-23-43-47-20230127234329.png" alt="" width="510" data-align="center">

从上图中可以看出，put(y, 2)依赖于put(x, 1)， get(y)依赖于put(y, 2)，不同client之间的不同数据是没有因果关系的，**这就是依赖链条，这些操作之间存在着因果关系，根据依赖关系可以从后往前寻找。这就是所谓因果一致性**。

在COPS中，应用程序只会去执⾏get和put操作，而不需要去关注数据的版本，COPS库内部维护了这些上下⽂信息，并将这些额外的信息添加到put RPC中，应用程序只需要get和put即可。这种方案不需要sync或者logging服务器，通信也是独立的。

另外，在数据中心，数据是分片存储的，对于不同分片服务器上且没有因果关系的数据，完全可以实现并行写入，从而获得不错的性能。

**强一致性、弱一致性、最终一致性、读写一致性、单调读、因果一致性 的区别与联系：**

https://zhuanlan.zhihu.com/p/67949045/
