# CRAQ

## 1. Chain Replication（链复制）系统

在Chain Replication中，服务器按照链排列。第一个服务器称为HEAD，最后一个被称为TAIL。 

- 关于写请求：
  
  1. 当客户端想要发送一个写请求，写请求总是发送给HEAD；
  
  2. HEAD根据写请求更新本地数据，我们假设现在是一个支持PUT/GET的key-value数据库。所有的服务器本地数据都从A开始；
  
  3. 当HEAD收到了写请求，将本地数据更新成了B，之后会再将写请求通过链向下一个服务器传递；
  
  4. 下一个服务器执行完写请求之后，再将写请求向下一个服务器传递，以此类推，所有的服务器都可以看到写请求；
  
  5. 当写请求到达TAIL时，TAIL将回复发送给客户端，表明写请求已经完成了。这是处理写请求的过程；

- 关于读请求：
  
  1. 对于读请求，如果一个客户端想要读数据，它将读请求发往TAIL；
  
  2. TAIL直接根据自己的当前状态来回复读请求。所以，如果当前状态是B，那么TAIL直接返回B。

从一个全局角度来看，除非写请求到达了TAIL，否则一个写请求是不会commit，也不会向客户端回复确认，也不能将数据通过读请求暴露出来；而为了让写请求到达TAIL，它需要经过并被链上的每一个服务器处理。

所以我们知道，一旦我们commit一个写请求，一旦向客户端回复确认，那意味着链上的每一个服务器都知道了这个写请求。

## 2. 链复制的故障恢复（Fail Recover）

一条链上的服务器都有发生故障的可能，因此链复制系统设计了故障恢复机制：

- HEAD服务器故障
  
  如果HEAD出现故障，作为最接近的服务器，下一个节点可以接手成为新的HEAD，并不需要做任何其他的操作；
  
  此时存在一个问题：之前发送给HEAD的写请求怎么办？要不要传到后面去？这里分两种情况来处理：
  
  - 对于任何已经发送到了第二个节点的写请求，不会因为HEAD故障而停止转发，它会持续转发直到commit；
  
  - 如果写请求发送到HEAD，在HEAD转发这个写请求之前HEAD就故障了，那么这个写请求必然没有commit，我们只需要等待客户端再次发送写请求给新的HEAD。

- TAIL服务器故障
  
  如果TAIL出现故障，处理流程也非常相似，TAIL的前一个节点可以接手成为新的TAIL。所有TAIL知道的信息，TAIL的前一个节点必然都知道，因为TAIL的所有信息都是其前一个节点告知的；

- 中间服务器故障
  
  如果中间服务器故障，方案是将故障节点从链中移除。或许有一些写请求被故障节点接收了，但是还没有被故障节点之后的节点接收，所以当我们将其从链中移除时，故障节点的前一个节点或许需要重发最近的一些写请求给它的新后继节点。这是恢复中间节点流程的简单版本。

但这存在网络分区带来的脑裂（brain split）问题：

当HEAD和第二个节点的网络发生故障时，第二个节点会认为HEAD故障而接替成为HEAD，但实际上HEAD还在正常运行，同时HEAD认为第二个节点挂了。

所以现在他们都会认为，另一个服务器挂了，我应该接管服务并处理写请求。因为从HEAD看来，其他服务器都失联了，HEAD会认为自己现在是唯一的副本，那么它接下来既会是HEAD，又会是TAIL；第二个节点会有类似的判断，会认为自己是新的HEAD。所以现在有了脑裂的两组数据，最终，这两组数据会变得完全不一样。

**所以，Chain Replication并不能抵御网络分区，也不能抵御脑裂。**

## 3. 链复制的配置管理器（Configuration Manager）

为了解决链复制系统的脑裂问题，需要一个外部的权威（External Authority）来决定谁是活的，谁挂了，并确保所有参与者都认可由哪些节点组成一条链，这样在链的组成上就不会有分歧。这个外部的权威通常称为Configuration Manager。

Configuration Manager的工作就是监测节点存活性，一旦Configuration Manager认为一个节点挂了，它会生成并送出一个新的配置，在这个新的配置中，描述了链的新的定义，包含了链中所有的节点，HEAD和TAIL。Configuration Manager认为挂了的节点，或许真的挂了也或许没有，但是我们并不关心。因为所有节点都会遵从新的配置内容，所以现在不存在分歧了。

## 4. Chain Replication和Raft

- Chain Replication的优势：Chain Replication更加的高效，因为它减轻了Leader的负担，尤其是存在大量读操作的时候。当然Zookeeper也减轻了读操作的压力，但是它没有做到完全的线性一致；

- Chain Replication的劣势：写请求处理很慢，因为每一个写请求都需要经过所有副本，只要有一个副本服务器变慢了，就会使得所有的写请求处理变慢。而Raft只需要过半节点完成写操作即可。
