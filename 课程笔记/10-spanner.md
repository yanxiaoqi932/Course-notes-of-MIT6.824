# Spanner

## 1. spanner概述

spanner是google使用的分布式事务系统，它采用了两种基本思想：

- 使用两阶段提交（2PC）来完成分布式事务，同时为了避免两阶段提交中的事务协调器崩溃而导致所有参与者阻塞这一情况，他们在spanner中使用了paxos；

- spanner通过同步时间来实现非常高效的只读事务。

spanner的基本架构如下所示：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-13-17-59-32-20230113172621.png" alt="" width="467" data-align="center">

每个服务器都有多个副本，分布在不同的数据中心上，多副本有两个好处：

1. 当一个副本故障后，另一个副本可以快速替代，保证两阶段执行协议顺利完成；

2. 当大量客户端进行只读操作时，客户端只需要发送只读消息给最近的副本就可以，这种并行的读取大大提高了只读事务的处理速度。

## 2. Spanner的执行过程

### 2.1 Spanner对读写事务的执行

假设需要对X账户加一，对Y账户减一，那么spanner的基本执行过程如下所示：

1. 客户端首先需要向X和Y两个paxos组发送读请求，分别读取x和y；

2. 客户端在x和y两个paxos组之间选出一个作为事务协调器，这里选择y作为TC；

3. 客户端完成计算后，向x的leader发出写操作指令，x的leader向所有副本发送prepare，得到通过后发送yes给事务协调器y；

4. 客户端向y的leader发出写操作指令，y的leader向所有副本发送prepare，得到通过后发送yes给自己；

5. y作为TC，一方面将commit发送给自己的所有副本，另一方面将commit发送给x的leader，x的leader再转发给x的所有副本；

6. 完成一切之后，y将结果返回给客户端。

在整个执行过程中，如果有leader故障了，它的副本会立刻接管，保持了两阶段提交的顺利执行。

流程如下图所示：

<img src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-13-18-25-56-20230113182353.png" title="" alt="" data-align="center">

### 2.2 Spanner对只读事务的执行

对于只读事务，客户端会直接从距离它最近（本地）的副本服务器中直接读取。

但是只读事务要注意到一个问题，为了提高只读事务处理的速度，Spanner没有使用锁，但是只读事务必须和其它事务隔离开来，它读取的值必须都是同一个读写事务完成后的系统的值，而不能是多个串行读写事务执行后的值，也就是必须统一版本。例如以下情况就是只读事务的两个值版本不统一：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-13-19-45-10-20230113194447.png" alt="" width="508" data-align="center">

对于这个问题，Spanner让所有服务器的所有事务记录都带有一个时间戳：

- 对于读写（R/W）事务，它的时间戳是它commit的时刻；

- 对于只读（R/O）事务，它的时间戳是它开始的时刻。

**当只读事务去读取服务器的记录时，它会读取最新但是时间戳小于它的时间戳的记录，这就解决了多版本的问题，这称为快照隔离（snapshot isolation）。** 该方案会存储一条记录的多个版本，过于老旧的版本会被丢弃掉，避免存储开销过大。

但是该方案依然存在一些问题：

- 如果客户端读取的副本是paxos中的少数派，它没有得到最新的记录版本，这种情况下客户端读取的记录就不是最新的。这里spanner采用了安全时间机制（safe time），被读取的副本只有从leader那里得到客户端读取时间戳之前的所有信息，才会响应客户端的读取，这保证了客户端读取到正确的内容，但延长了响应时间。

- 不同机器的时钟流速会有一定的差异。如果客户端时钟太快，则只读事务时间戳过大，这虽然可以读取到最新的数据，但是由于前面的安全时间机制，响应时间会比较长；如果时钟太慢，则只读事务时间戳太小，那么就会错过新的数据，这不符合外部一致性。因此spanner设计了时间戳同步机制：
  
  - 控制时钟偏移
    
    Spanner实现了一个基于硬件的（GPS和原子钟）TrueTime时间戳接口，用Spanner的话来说就是“这个接口直接暴露了时间的不确定性”，其实就是通过这个接口，可以获取一个时间区间[earliest, latest]，尽管存在时钟偏移，但是偏移最早不会早于earliest，最晚不会晚于latest，如果假设绝对时间是t的话，那么这个区间就是[t-  , t+  ]。通常Spanner能将集群中最大的时钟偏移  控制在10ms以内。正是由于  足够小，所以才能通过下面的方法实现外部一致性。
  
  - commit wait
    
    因为通过TrueTime已经将时钟偏移控制地足够小了，所以Spanner实现外部一致性（externally consistent）的方式十分简单粗暴，那就是等待（wait）直到通过TrueTime获取的now时间区间的左边界也大于这个事务的提交时间戳，这样就不会由于时钟偏移导致事务乱序了。
  
  具体可以参考博客：[https://zhuanlan.zhihu.com/p/449151546]()
