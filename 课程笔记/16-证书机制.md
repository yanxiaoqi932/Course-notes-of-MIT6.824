# 证书机制

## 1. 背景概述

在raft等分布式系统中，节点之间的通信往往是互相信任的，但是实际上不同节点之间可能存在欺诈，例如有第三方服务器伪装成系统节点，从而获取信息。

在客户端浏览器访问网站时，往往需要从DNS服务器那里获取网站服务器的IP地址，这就存在一个“中间者攻击”——黑客截获DNS的回复，修改IP地址后发送给浏览器，浏览器访问伪装的网站服务器后，这个服务器会获取到客户的隐私信息。

为了防范中间者攻击，证书机制应运而生。当网站服务器最初注册时，第三方证书机构会给它颁发一个证书，客户端获取到服务器的ip地址后，会要求服务器出示这个证书，通过一系列密码验证来证明自己不是伪装的服务器。

## 2. 伪证书的出现

但是后来出现了越来越多的证书机构，这些证书机构会有意无意地给一些伪装的黑客服务器颁发证书，这些证书就是伪证书。为了辨别网站服务器出示的证书是否真实，网站系统建立了证书日志系统，把自己获取过的所有证书的信息都存储在日志系统中，并且还建立了监视系统（certifificate transparency）来辨别日志系统中是否存在伪证书。这样，当客户浏览器访问网站服务器时，服务器不仅要出示证书，客户端还要验证这个证书是否存在于证书日志系统中，只有这样才能保证服务器是真的。整体架构如下图：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-29-15-01-01-20230129150044.png" alt="" width="583" data-align="center">

## 3. 证书日志系统的篡改

这种情况下依然存在一些问题，证书日志系统有可能被篡改，将伪证书存在日志系统中，然后复制一份无伪证书的日志副本发送给监视系统检查，这样就可以实现伪证书的保留，日志系统通过这个办法“说谎”。因此，证书日志系统必须防止删除操作，也就是append-only。

对此，日志系统采用Merkle tree，又称STH（signed tree head），将日志系统中存储的证书hash成一串数字，在浏览器访问时发送给浏览器和监视系统，STH的输入和输出是一对一的，因此如果日志系统后面删除了某些证书再发送给监视系统，则hash值对应不上，所以用这个办法可以辨别日志系统是否“说谎”。STH方案如下所示：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-29-16-04-01-20230129160124.png" alt="" width="502" data-align="center">

STH中每两个证书合成一个hash，这些hash继续向上合并，直到合并成一个hash为止。

## 4. 证书日志系统的fork攻击

证书日志系统通过STH方案来防止日志内容被修改后发给监视系统，这就导致监视系统和浏览器看到的不是同一个日志副本，但是依然存在一个漏洞：日志系统可以不修改，来使监视系统和浏览器看到不一样的日志副本。

具体来说，日志系统的证书按照以下结构来存储：

<img title="" src="file:///E:/研究生/其它事务/分布式系统/课程笔记/images/2023-01-29-16-22-26-20230129162219.png" alt="" width="445" data-align="center">

正常的证书存储结构是完全一条线的，这个结构可以让日志系统生成两种hash值，当浏览器访问时，STH1不包含伪证书B，用来发送给监视系统；STH2包含伪证书，用来发送给浏览器。这个结构看起来像一个叉子，因此对日志系统的篡改就称为fork攻击，又称分支攻击。

对此，监视系统certifificate transparency中有⼀个叫做gossip的规定，所有的参与者会将它们最近看到的STH丢进这个pool中，它们会试着去弄清楚这⾥⾯是否存在不⼀致的STH（因为存在分支的日志系统，它的不同时刻生成的STH们，不会是完全的包含关系），这就能很清楚地检查出⽇志中是否存在着分⽀。
