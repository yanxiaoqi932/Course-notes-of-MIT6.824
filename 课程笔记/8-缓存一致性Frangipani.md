# 缓存一致性Frangipani

论文解读链接：[MIT 6.824 Frangipani论文精读_寒冰陨云的博客-CSDN博客_frangipani 论文](https://blog.csdn.net/weixin_46840831/article/details/124423803)

## 1. Frangipani基本架构

Frangipani基本架构如下所示：

<img title="" src="https://img-blog.csdnimg.cn/9716579e001648329fc886ee98fa8aa4.png" alt="" data-align="center" width="436">

- Frangipani file server基本上处于用户的工作站内，属于控制部分；

- Petal server则在架构中扮演存储服务器的角色；

- Lock server用于保证缓存一致性。

## 2. Frangipani在缓存一致性上的挑战

### 2.1 节点之间的缓存同步

假设工作站W1创建了一个文件 /A。最初，这个文件只会在本地缓存中创建。也就是说，Frangipani需要从Petal获得 ***/*** 目录下的内容，之后当创建文件时，工作站只是修改缓存的拷贝，并不会将修改立即返回给Petal。

假设工作站W2上的用户想要获取 ***/*** 目录下的文件列表，我们希望这个用户可以看到新创建的文件 /A。这意味着，文件系统必须要做一些事情来确保客户端可以读到最新的写入文件，这通常被称为缓存一致性（Cache Coherence）。**它表明，如果我缓存了一个数据，并且其他人在他的缓存中修改了这个数据，那么我的缓存需要自动地应用那个修改。**

### 2.2 缓存写入的原子性

另一个问题是，因为所有的文件和目录都是共享的，非常容易会有两个工作站在同一个时间修改同一个目录。假设用户U1在他的工作站W1上想要创建文件 /A，这是一个在 ***/*** 目录下的新文件，同时用户U2在他的工作站W2上想要创建文件 /B 。

所以这里的问题是，当他们同时操作时，会不会出现互相干扰的现象？正常的结果应该是，A和B最后都要创建成功，我们不想第二个文件的创建有可能会覆盖并取代第一个文件。这里期望的行为有很多种叫法，但是这里我们称之为原子性（Atomicity）。

### 2.3 工作站崩溃问题

最后一个问题是，假设我的工作站修改了大量的内容，由于Write-Back缓存，可能会在本地的缓存中堆积了大量的修改。如果我的工作站崩溃了，但是这时这些修改只有部分同步到了Petal，还有部分仍然只存在于本地。同时，其他的工作站还在使用文件系统。那么，我的工作站在执行操作的过程中的崩溃，最好不要损坏其他人同样会使用的文件系统。

我们需要的是单个服务器的故障恢复，我希望我的工作站的崩溃不会影响其他使用同一个共享系统的工作站。

## 3. Frangipani的锁服务

Frangipani的缓存一致性核心是由锁保证的。逻辑上，锁服务器是独立的服务器，但是实际上它与Petal服务器运行在一起。在锁服务器里面，有一个表单，就叫做locks。

在这个例子中，我们假设锁是排他锁（Exclusive Lock）。（尽管实际上Frangipani中的锁更加复杂可以支持两种模式：要么允许一个写入者持有写入锁，要么允许多个读取者持有读取锁。）

假设文件X最近被工作站WS1使用了，所以WS1对于文件X持有锁。同时文件Y最近被工作站WS2使用，所以WS2对于文件Y持有锁。锁服务器会记住每个文件的锁被谁所持有，同时在每个工作站中，Frangipani模块也会有一个lock表单，表单会记录文件名、对应的锁的状态和文件的缓存内容。

锁服务基本遵循以下原则：

- 必须先从锁服务器获得锁，然后才能从Petal中读取数据；

- 如果发生写入操作，必须先向Petal存储系统写入数据，再释放锁。

- 最后需要从工作站的lock表单中删除关文件的锁的记录和缓存的数据。

## 4. 利用锁服务实现缓存一致性协议

利用锁来实现缓存一致性协议的基本原则：

如果锁服务器（LS）收到工作站的锁请求：

- 如果不存在该文件，则直接创建该文件的锁并传递给工作站；

- 如果存在该文件而且没有其它工作站占有锁，也直接传递锁给工作站；

- 如果存在该文件但是其它工作站占据它的锁，如果锁是Idle状态，则要求持有者释放锁，并传递给需要锁的工作站；

- 如果存在该文件但是其它工作站占据它的锁，如果锁是busy状态，则等待持有者完成工作转为Idle状态后，再释放锁，并传递给需要锁的工作站。

注意，**如果一个工作站占据锁之后，完成工作也就是结束busy状态后，它并不会释放锁，而是转为Idle状态，因为它有更大概率后续会使用这个文件，只有LS要求它释放时，Idle状态才会转为释放，该优化可以提高获取锁的整体效率**。

利用锁来实现缓存一致性协议的基本过程：

1. 首先我们有了2个工作站（WS1，WS2），一个锁服务器（LS）。如果WS1想要读取并修改文件Z。在它从Petal读取文件之前，它需要先获取对于Z的锁，所以它向锁服务器发送Request消息；

2. 如果当前没有人持有对文件Z的锁，或者锁服务器没听过对于文件Z的锁（初始化状态），锁服务器会在lock表单中增加一条记录，并返回Grant消息给工作站说，你现在持有了对于Z文件的锁；

3. 工作站WS1持有了对文件Z的锁，并且被授权可以从Petal读取Z的数据。所以这个时间点，WS1会从Petal读取并缓存Z的内容，也可以在本地缓存中修改Z的内容；

4. 过了一会，工作站WS2也想读取文件Z，但是一开始WS2并没有对于文件Z的锁，所以它要做的第一件事情就是向锁服务器发送Request消息，请求对于文件Z的锁；

5. WS1现在还持有文件Z的锁，所以锁服务器会向WS1发送Revoke消息，告诉他有人需要这个锁；

6. 工作站WS1在向Petal写入修改数据之前，不允许释放锁，它现在会将任何修改的内容写回给Petal；

7. 写入结束之后，WS1转为Idle状态，此时它才会注意到LS发来的Revoke消息，这时它向锁服务器发送Release消息，表示释放这个锁；

8. 当锁服务器收到了这条Release消息时，锁服务器会更新自己的表单，并最终将Grant消息发送给工作站WS2，表示它现在持有了文件Z的锁。

整体过程如下图所示：

![](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MFuJRt3Jts5mw0kTCdD%2F-MFwwQu0gml2wioq39yR%2Fimage.png?alt=media&token=c9e88f71-36a2-4701-94af-5b7f310339cb)

## 5. 利用锁服务实现原子性

**总体来说，为了实现原子性，Frangipani需要获取执行操作所需要的所有数据的锁。**

在工作站完全完成操作之前，Frangipani确保其他的工作站看不到工作站的修改。首先工作站需要获取所有我需要读写数据的锁，**在完成操作之前，工作站不会释放任何一个锁**。并且为了遵循一致性规则，将所有修改了的数据写回到Petal之后，我的工作站才会释放所有的锁。比如我将文件从一个目录移到另一个目录，这涉及到修改两个目录的内容，我不想让人看到两个目录都没有文件的状态。

对于缓存一致性，Frangipani使用锁来确保写操作可以被看见；但是对于原子性来说，锁确保了人们在操作完成之前看不到任何写操作，因为在所有的写操作完成之前，工作站持有所有的锁。

## 6. 故障恢复

Frangipani与其他的系统（例如Aurora）一样，需要通过预写式日志（Write-Ahead Log，WAL）实现故障可恢复的事务（Crash Recoverable Transaction）。

当一个工作站需要完成涉及到多个数据的复杂操作时，在工作站向Petal写入任何数据之前，工作站会在Petal中自己的Log列表中追加一个Log条目，这个Log条目会描述整个的需要完成的操作。**只有当这个描述了完整操作的Log条目安全的存在于Petal之后，工作站才会开始向Petal发送数据。**

但是Frangipani保存Log的特点是，它在Petal server中对于每个工作站都保存了一份独立的Log。如果工作站崩溃了，它的Log可以被其他工作站从Petal中获取到。

每个Log条目有一个自己的编号，用来描述一个特定操作中所涉及到的所有数据修改的数组。数组中的每一个元素会有一个Petal中的块号（Block Number），一个版本号和写入的数据。

发生的故障有以下几种场景和处理方式：

- 第一种场景是，工作站WS1在向Petal写入任何信息之前就故障了。这意味着，当其他工作站WS2执行恢复，查看崩溃了的工作站的Log时，发现里面没有任何信息，自然也就不会做任何操作；

- 第二种场景是，工作站WS1向Petal写了部分Log条目。这样的话，执行恢复的工作站WS2会从Log的最开始向后扫描，直到Log的序列号不再增加，因为这必然是Log结束的位置。工作站WS2会检查Log条目的更新内容，并向Petal执行Log条目中的更新内容。
  
  当WS2执行完WS1存放在Petal中的Log后，它会通知锁服务器，之后锁服务器会释放WS1持有的锁。

注意，实际上一个数据块往往会被多个工作站修改，因此在恢复过程中，如果被恢复数据的Log版本号低于该数据块当前的版本号，说明有其它工作站已经执行了更新的写入，因此不会对该数据块执行恢复操作。
