# 分布式事务（Distributed Transaction）

## 1. 分布式事务概述

分布式事务主要有两部分组成。第一个是并发控制（Concurrency Control），第二个是原子提交（Atomic Commit）。

可以这么理解事务：程序员有一些不同的操作，这些操作的集合成为事务。或许针对数据库不同的记录，**在多个事务并行处理时，他们希望一个事务作为一个整体，不会因为失败而被分割，也不会被其他活动看到中间状态。** 事务处理系统要求程序员对这些读操作、写操作标明起始和结束，这样才能知道事务的起始和结束。事务处理系统可以保证在事务的开始和结束之间的行为是可预期的。

数据库通常对于正确性有一个概念称为ACID。分别代表：

- Atomic，原子性。它意味着，事务可能有多个步骤，比如说写多个数据记录，尽管可能存在故障，但是要么所有的写数据都完成了，要么没有写数据能完成，不能出现只执行了一部分的情况；

- Consistent，一致性。通常是指数据库会强制某些应用程序定义的数据不变；

- Isolated，隔离性。它表明两个同时运行的事务，在事务结束前，不能看到另一个事务中间的临时的更新。隔离性（Isolated）意味着可序列化（Serializable），**可序列化是指并行的执行一些事物得到的结果，与按照某种串行的顺序来执行这些事务，可以得到相同的结果**；

- Durable，持久化的。这意味着，在事务提交之后，在客户端或者程序提交事务之后，在数据库中的修改是持久化的，它们不会因为一些错误而被擦除。

举例如下：

假设运行一个银行，一半用户的账户在一个服务器，另一半用户的账户在另一个服务器，这样的话可以同时满足负载分担和存储空间的要求。现在需要执行两个事务：

- 从用户Y转账到用户X，这两个账户最开始都有10块钱，这里的X，Y都是数据库的记录；

- 转账的同时，我们还有一个事务，会检查转账涉及的所有的账户，对所有账户进行审计，确保尽管可能存在转账，但是所有账户的金额加起来总数是不变的。

该情况下只有两种一次一个的串行顺序，要么是T1，T2，要么是T2，T1。如果T1执行了一半然后执行T2，那么T2读取到的结果是错误的。

## 2. 并发控制（Concurrency Control）

### 2.1 并发控制的几种策略

并发控制就是可序列化的别名，通过与其他尝试使用相同数据的并发事务进行隔离，可以实现可序列化。

并发控制可以分为两大类：

- 悲观并发控制
  
  在事务使用任何数据之前，它需要获得数据的锁。如果一些其他的事务已经在使用这里的数据，锁会被它们持有，当前事务必须等待这些事务结束，之后当前事务才能获取到锁。**在悲观系统中，如果有锁冲突，比如其他事务持有了锁，就会造成延时等待，所以这里需要为正确性而牺牲性能。**

- 乐观并发控制
  
  这里的基本思想是，你不用担心其他的事务是否正在读写你要使用的数据，你直接继续执行你的读写操作，**只有在事务最后的时候，你再检查是不是有一些其他的事务干扰了你**。如果没有，那么你的事务就完成了，并且你也不需要承受锁带来的性能损耗；如果有一些其他的事务在同一时间修改了你关心的数据，并造成了冲突，那么你必须要Abort当前事务，并重试。

这里主要讨论悲观并发控制，涉及到的锁机制为两阶段锁（Two-Phase Locking），这是一种最常见的锁。

### 2.2 两阶段锁协议

两阶段锁协议遵守两个原则：

- 事务在执行任何数据的读写之前，必须先获取对应数据的锁；

- **事务必须持有任何已经获得的锁，直到事务提交或者Abort，你不允许在事务的中间过程释放锁**。你必须要持有所有的锁，并不断的累积你持有的锁，直到你的事务完成了。

两阶段锁的两个阶段，第一个阶段获取锁，第二个阶段是在事务结束前一直持有锁。**之所以不愿意在中途释放锁，是为了保证隔离性，中途释放锁会让其它事务读取到该事务执行的中间状态**。

两阶段锁有两个缺点：

- 性能较低，事务T2必须等待事务T1完全结束后释放数据的锁，才能对数据进行读写；

- 可能引起死锁，例如事务T1获取了数据X的锁，同时事务T2获取了Y的锁，此时T1还想要Y的锁，T2想要X的锁，而它们都不会释放已经获取的锁，因此引起死锁。（实际上，事务有各种各样的策略，包括了判断循环，超时来判断它们是不是陷入到这样一个场景中。如果是的话，数据库会Abort其中一个事务，撤回它所有的操作，并表现的像这个事务从来没有发生一样。）

### 2.3 两阶段提交协议

原子提交协议的风格是：假设有一批计算机，每一台都执行一个事务的不同部分，原子提交协议将会帮助计算机来决定它是否能够执行它对应的工作，它是否执行了对应的工作，如果某个部分出错了，所有计算机都要同意，没有一个会执行自己的任务。

如果某台机器执行事务的某部分发生了故障，那么其它机器也应该撤回自己在这事务上的所有操作。

在两阶段提交协议中，有一个计算机会用来管理事务，它被称为事务协调者（Transaction Coordinator），我们这里就假设它是一个实际运行事务的计算机，其它服务器被称为参与者（Participants）。 **事务协调者以某种形式运行事务的代码，例如Put/Get/Add，它向持有了不同数据的其他计算机发送消息，其他计算机再执行事务的不同部分。**

例如，我们有一个计算机作为事务协调者（TC），然后还有服务器S1，S2，分别持有X，Y的记录。执行一个转账事务时，事务协调者会向服务器S1发消息说，请对X加1，向服务器S2发消息说，请对Y减1。之后会有更多消息来确认，要么两个服务器都执行了操作，要么两个服务器都没有执行操作。

因此，在两阶段协议中，事务的执行过程如下：

1. 有一个外部的客户端C，它在最最开始的时候会向TC发请求说，请运行这个事务。并且之后这个客户端会等待回复；

2. 在开始执行事务时，TC需要确保所有的事务参与者能够完成它们在事务中的那部分工作，因此它会向所有的参与者发送Prepare消息；

3. 当参与者A或者B收到了Prepare消息，它们就知道事务要执行但是还没执行的内容，它们会查看自身的状态并决定它们实际上能不能完成事务。或许它们需要Abort这个事务因为这个事务会引起死锁，或许它们在故障重启过程中并完全忘记了这个事务因此不能完成事务。
   
   总之，A和B会检查自己的状态，并向TC回复Yes或者No；

4. 事务协调者会等待来自于每一个参与者的这些Yes/No投票。
   
   如果所有的参与者都回复Yes，那么事务可以提交，事务协调者会发出一个Commit消息给每一个事务的参与者；
   
   如果不是，它会发送一轮Abort消息给所有的参与者说，请撤回这个事务；

5. 在事务Commit之后，事务协调者会向客户端发送代表了事务输出的内容，表明事务结束并且被持久化保存起来了。此外为了遵守前面的两阶段锁协议，事务参与者会释放锁（这里不论Commit还是Abort都会释放锁）。

**在两阶段提交协议中，两个参与者只会一起Commit，如果其中一个需要Abort，那么它们两个也会一起Abort。**

两阶段提交协议过程如下图所示：

![](https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MGDMi39kJWJ6Q51aoWN%2F-MGDPY7MBEk7On-h9bJ0%2Fimage.png?alt=media&token=4c6f3600-5fce-4d73-a05a-3c43487294d8)

## 3. 故障恢复

在两阶段提交中，存在以下的一些故障场景，以及两阶段提交协议的应对方案：

- 参与者B可能在回复事务协调者的Prepare消息之前崩溃。TC会重复发送Prepare消息给它，故障之后B不知道任何有关事务的信息，也不知道给谁回复过Yes。**如果事务协调者发送了一个Prepare消息过来，因为B不知道事务，B会回复No，并要求Abort事务**；

- B在回复了Yes给事务协调者的Prepare消息之后，收到commit消息之前崩溃。B已经承诺可以commit，因为它回复了Yes。接下来极有可能发生的事情是，事务协调者从所有的参与者获得了Yes的回复，并将Commit消息发送给了A，所以A实际上会执行事务分包给它的那一部分，持久化存储结果，并释放锁。这样的话，为了确保All-or-Nothing原子性，我们需要确保B在故障恢复之后，仍然能完成事务分包给它的那一部分。
  
  **所以在B回复Yes给Prepare消息之前，它首先要将相应的Log写入磁盘，并在Log中记录所有有关提交事务必须的信息。** 之后，如果B在发送完Yes之后崩溃了，当它重启恢复时，通过查看自己的Log，它可以发现自己正在一个事务的中间，并且对一个事务的Prepare消息回复了Yes。当B最终收到了Commit，通过读取Log，B就知道如何完成它在事务中的那部分工作。

- B可能在收到Commit之后崩溃了。但是这样的话，B就完成了修改，并将数据持久化存储在磁盘上了。这样的话，故障重启就不需要做任何事情，因为事务已经完成了。
  
  但是事务协调者因为没有收到ACK，会再次发送Commit消息。当B重启之后，收到了Commit消息时，对于一个它不知道事务的Commit消息，B会简单的ACK这条消息。这样整个流程就完成了。

- 事务协调者在发送Commit消息之前崩溃。在这种情况下，它可以直接Abort事务。**但是在TC发送Abort信息给参与者之前，对Prepare回复Yes的参与者，必须一直等待TC的commit或abort回复，不能自行abort，这种情况称为Block**。

- 事务协调者在发送完一个或者多个Commit消息之后崩溃。这种情况下不允许它忘记相关的事务。因此在发送任何Commit消息之前，TC必须先将事务的信息写入到自己的Log，并存放在例如磁盘的持久化存储中，这样计算故障重启了，信息还会存在。

- 由于网络崩溃，事务协调者发送了Prepare消息，但是并没有收到所有的Yes/No消息。这种情况下TC会重新发送一轮Prepare消息，表明自己没有收到全部的Yes/No回复。事务协调者可以持续不断的重发Prepare消息。没有收到Yes/No回复一段时间之后，它可以单方面地Abort事务。

参与者发送完ACK之后，可以完全删除相关的事务的Log；事务协调者成功地收到了所有参与者的ACK之后，可以删除有关事务的Log。

## 4. 总结

两阶段提交对于故障来说是非常脆弱的，在故障时它可以有正确的结果，但是不具备可用性。所以这里的问题是，是否可以构建一个合并的系统，同时具备Raft的高可用性，但同时又有两阶段提交的能力将事务分包给不同的参与者。

可以考虑将两阶段协议与Raft结合起来，使之既能够将事务分给不同参与者完成，又能够避免因为故障恢复而产生的低可用性。示例如下：

我们会有三个不同的集群，事务协调器和两个参与者实际上各自都是一个集群：

<img title="" src="https://906337931-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MAkokVMtbC7djI1pgSw%2F-MGDo7lTac6bjSnx42qj%2F-MGHRamLcjPxIGu7ad95%2Fimage.png?alt=media&token=6bf33cfc-e690-4025-8840-f3657c5f23fc" alt="" width="605" data-align="center">
